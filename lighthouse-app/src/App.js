import React from "react";
import { ethers } from 'ethers';
import lighthouse from '@lighthouse-web3/sdk';
import env from "react-dotenv";


function App() {

const LIGHTHOUSE_API_KEY=process.env.LIGHTHOUSE_API_KEY;

/////////
// Upload
/////////
  const progressCallback = (progressData) => {
    let percentageDone =
      100 - (progressData?.total / progressData?.uploaded)?.toFixed(2);
    console.log(percentageDone);
  };

  const deploy = async(e) =>{
    // Push file to lighthouse node
    // Both file and folder supported by upload function


    const output = await lighthouse.upload(e, LIGHTHOUSE_API_KEY, progressCallback);
    console.log('File Status:', output);
    /*
      output:
        {
          Name: "filename.txt",
          Size: 88000,
          Hash: "QmWNmn2gr4ZihNPqaC5oTeePsHvFtkWNpjY3cD6Fd5am1w"
        }
      Note: Hash in response is CID.
    */

      console.log('Visit at https://gateway.lighthouse.storage/ipfs/' + output.data.Hash);
  }

////////////////////
// Upload Encrypted
////////////////////

  const encryptionSignature = async() =>{
    const provider = new ethers.providers.Web3Provider(window.ethereum);
    await provider.send('eth_requestAccounts', []); // <- this promps user to connect metamask
    const signer = provider.getSigner();
    const address = await signer.getAddress();
    const messageRequested = (await lighthouse.getAuthMessage(address)).data.message;
    const signedMessage = await signer.signMessage(messageRequested);
    return({
      signedMessage: signedMessage,
      publicKey: address
    });
  }


  /* Deploy file along with encryption */
  const deployEncrypted = async(e) =>{
    /*
       uploadEncrypted(e, publicKey, accessToken, uploadProgressCallback)
       - e: js event
       - publicKey: wallets public key
       - accessToken: your api key
       - signedMessage: message signed by the owner of publicKey
       - uploadProgressCallback: function to get progress (optional)
    */
    const sig = await encryptionSignature();
    const response = await lighthouse.uploadEncrypted(
      e,
      sig.publicKey,
      LIGHTHOUSE_API_KEY,
      sig.signedMessage,
      progressCallback
    );
    console.log(response);
    /*
      output:
        {
          Name: "c04b017b6b9d1c189e15e6559aeb3ca8.png",
          Size: "318557",
          Hash: "QmcuuAtmYqbPYmPx3vhJvPDi61zMxYvJbfENMjBQjq7aM3"
        }
      Note: Hash in response is CID.
    */
  }


  ////////////////
  // Decrypt File
  ////////////////

  
    const [fileURL, setFileURL] = React.useState(null);
  
    const sign_auth_message = async() =>{
      const provider = new ethers.providers.Web3Provider(window.ethereum);
      const signer = provider.getSigner();
      const publicKey = (await signer.getAddress()).toLowerCase();
      const messageRequested = (await lighthouse.getAuthMessage(publicKey)).data.message;
      const signedMessage = await signer.signMessage(
        messageRequested
      );
      return({publicKey: publicKey, signedMessage: signedMessage});
    }
  
    /* Decrypt file */
    const decrypt = async() =>{
      // Fetch file encryption key
      const cid = "QmZ7kn64ozDHoRqQE2dQXXw9KC7a1YwHUwdVKu2FX9Kc9P"; //replace with your IPFS CID
      const {publicKey, signedMessage} = await sign_auth_message();
      console.log(signedMessage)
      /*
        fetchEncryptionKey(cid, publicKey, signedMessage)
          Parameters:
            CID: CID of the file to decrypt
            publicKey: public key of the user who has access to file or owner
            signedMessage: message signed by the owner of publicKey
      */
      const keyObject = await lighthouse.fetchEncryptionKey(
        cid,
        publicKey,
        signedMessage
      );
  
      // Decrypt file
      /*
        decryptFile(cid, key, mimeType)
          Parameters:
            CID: CID of the file to decrypt
            key: the key to decrypt the file
            mimeType: default null, mime type of file
      */
     
      const fileType = "image/jpeg";
      const decrypted = await lighthouse.decryptFile(cid, keyObject.data.key, fileType);
      console.log(decrypted)
      /*
        Response: blob
      */
  
      // View File
      const url = URL.createObjectURL(decrypted);
      console.log(url);
      setFileURL(url);
    }

//////////////////////////
// Apply Access Control
//////////////////////////


  const applyAccessConditions = async(e) =>{
    // CID on which you are applying encryption
    // CID is generated by uploading a file with encryption
    // Only the owner of the file can apply access conditions
    const cid = "QmXzW11XQDPHhcT6WNC54et78JyUz3kN4w45JGGivaLLYp";

    // Conditions to add
    const conditions = [
      {
        id: 1,
        chain: "Wallaby",
        method: "getBlockNumber",
        standardContractType: "",
        returnValueTest: {
          comparator: ">=",
          value: "13349"
        },
      },
    ];

    // Aggregator is what kind of operation to apply to access conditions
    // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
    const aggregator = "([1])";
    const {publicKey, signedMessage} = await encryptionSignature();

    /*
      accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
        Parameters:
          publicKey: owners public key
          CID: CID of file to decrypt
          signedMessage: message signed by owner of publicKey
          conditions: should be in format like above
          aggregator: aggregator to apply on conditions
    */
    const response = await lighthouse.accessCondition(
      publicKey,
      cid,
      signedMessage,
      conditions,
      aggregator
    );

    console.log(response);
    /*
      {
        data: {
          cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
          status: "Success"
        }
      }
    */
  }

  return (
    <div className="App">
      <h1>Upload</h1>
      <input onChange={e=>deploy(e)} type="file" />
      <h1>Upload Encrypted</h1>
      <input onChange={e=>deployEncrypted(e)} type="file" />
      <h1>Decrypt File</h1>
      <button onClick={()=>decrypt()}>decrypt</button>
        {
          fileURL?
            <a href={fileURL} target="_blank">viewFile</a>
          :
            null
        }
      <h1>Apply Access Conditions</h1>
      <button onClick={()=>{applyAccessConditions()}}>Apply Access Consitions</button>
    </div>
  );
}

export default App;